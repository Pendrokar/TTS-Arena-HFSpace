import gradio as gr
import pandas as pd
from langdetect import detect
from datasets import load_dataset
import threading, time, uuid, sqlite3, shutil, os, random, asyncio, threading
from pathlib import Path
from huggingface_hub import CommitScheduler, delete_file, hf_hub_download
from gradio_client import Client, handle_file
import pyloudnorm as pyln
import soundfile as sf
import librosa
from detoxify import Detoxify
import os
import tempfile
from pydub import AudioSegment
import itertools
from typing import List, Tuple, Set, Dict
from hashlib import md5, sha1
import spaces

class User:
    def __init__(self, user_id: str):
        self.user_id = user_id
        self.voted_pairs: Set[Tuple[str, str]] = set()

class Sample:
    def __init__(self, filename: str, transcript: str, modelName: str):
        self.filename = filename
        self.transcript = transcript
        self.modelName = modelName

def match_target_amplitude(sound, target_dBFS):
    change_in_dBFS = target_dBFS - sound.dBFS
    return sound.apply_gain(change_in_dBFS)

# from gradio_space_ci import enable_space_ci

# enable_space_ci()



toxicity = Detoxify('original')
sents = []
with open('harvard_sentences.txt') as f:
    sents += f.read().strip().splitlines()
with open('llama3_command-r_sentences_1st_person.txt') as f:
    sents += f.read().strip().splitlines()
# With other punctuation marks
# Exclamations - # conversational characters/animation entertainment/tv
with open('llama3_command-r_sentences_excla.txt') as f:
    sents += f.read().strip().splitlines()
# Questions - # conversational characters/animation entertainment/tv
with open('llama3_command-r_questions.txt') as f:
    sents += f.read().strip().splitlines()

# Credit: llama3_command-r sentences generated by user KingNish

####################################
# Constants
####################################
AVAILABLE_MODELS = {
    # 'XTTSv2': 'xtts',
    # 'WhisperSpeech': 'whisperspeech',
    # 'ElevenLabs': 'eleven',
    # 'OpenVoice': 'openvoice',
    # 'OpenVoice V2': 'openvoicev2',
    # 'Play.HT 2.0': 'playht',
    # 'MetaVoice': 'metavoice',
    # 'MeloTTS': 'melo',
    # 'StyleTTS 2': 'styletts2',
    # 'GPT-SoVITS': 'sovits',
    # 'Vokan TTS': 'vokan',
    # 'VoiceCraft 2.0': 'voicecraft',
    # 'Parler TTS': 'parler'

    # HF Gradio Spaces: # <works with gradio version #>
    # gravio version that works with most spaces: 4.29
    'coqui/xtts': 'coqui/xtts', # 4.29 4.32
    # 'collabora/WhisperSpeech': 'collabora/WhisperSpeech', # 4.32 4.36.1 DEAD SPACE
    # 'myshell-ai/OpenVoice': 'myshell-ai/OpenVoice', # same devs as MeloTTS, which scores higher # 4.29
    # 'myshell-ai/OpenVoiceV2': 'myshell-ai/OpenVoiceV2', # same devs as MeloTTS, which scores higher # 4.29
    #'mrfakename/MetaVoice-1B-v0.1': 'mrfakename/MetaVoice-1B-v0.1', # 4.29 4.32 DEAD SPACE
    'Pendrokar/xVASynth-TTS': 'Pendrokar/xVASynth-TTS', # 4.29 4.32 4.42.0
    # 'coqui/CoquiTTS': 'coqui/CoquiTTS',
    'mrfakename/MeloTTS': 'mrfakename/MeloTTS', # 4.29 4.32
    'fishaudio/fish-speech-1': 'fishaudio/fish-speech-1', # 4.29 4.32 4.36.1

    # E2 & F5 TTS
    # F5 model
    'mrfakename/E2-F5-TTS': 'mrfakename/E2-F5-TTS', # 5.0

    # # Parler
    # Parler Large model
    # 'parler-tts/parler_tts': 'parler-tts/parler_tts', # 4.29 4.32 4.36.1 4.42.0
    # Parler Mini model
    'parler-tts/parler_tts': 'parler-tts/parler_tts', # 4.29 4.32 4.36.1 4.42.0
    # 'parler-tts/parler_tts_mini': 'parler-tts/parler_tts_mini', # Mini is the default model of parler_tts
    # 'parler-tts/parler-tts-expresso': 'parler-tts/parler-tts-expresso', # 4.29 4.32 4.36.1 4.42.0 # overlly jolly

    # # Microsoft Edge TTS
    'innoai/Edge-TTS-Text-to-Speech': 'innoai/Edge-TTS-Text-to-Speech', # 4.29

    # IMS-Toucan
    # 'Flux9665/MassivelyMultilingualTTS': 'Flux9665/MassivelyMultilingualTTS', # 5.1 # randomly changes pitch

    # IMS-Toucan English non-artificial
    'Flux9665/EnglishToucan': 'Flux9665/EnglishToucan', # 5.1

    # StyleTTS v2
    # 'Pendrokar/style-tts-2': 'Pendrokar/style-tts-2', # saving ZeroGPU resources; more votes in OG arena; emotionless
    # StyleTTS kokoro
    'hexgrad/kokoro': 'hexgrad/kokoro',

    # MaskGCT (by Amphion)
    # DEMANDS 300 seconds of ZeroGPU
    # 'amphion/maskgct': 'amphion/maskgct',
    # default ZeroGPU borrow time
    'Svngoku/maskgct-audio-lab': 'Svngoku/maskgct-audio-lab',

    # HF TTS w issues
    'LeeSangHoon/HierSpeech_TTS': 'LeeSangHoon/HierSpeech_TTS', # irresponsive to exclamation marks # 4.29
    # 'PolyAI/pheme': '/predict#0', # sleepy HF Space
    # 'amphion/Text-to-Speech': '/predict#0', # disabled also on original HF space due to poor ratings
    # 'suno/bark': '3#0', # Hallucinates
    # 'shivammehta25/Matcha-TTS': '5#0', # seems to require multiple requests for setup
    # 'styletts2/styletts2': '0#0', # API disabled, awaiting approval of PR #15
    # 'Manmay/tortoise-tts': '/predict#0', # Cannot retrieve streamed file; 403
    # 'pytorch/Tacotron2': '0#0', # old gradio
}

HF_SPACES = {
    # XTTS v2
    'coqui/xtts': {
        'name': 'XTTS v2',
        'function': '1',
        'text_param_index': 0,
        'return_audio_index': 1,
        'series': 'XTTS',
    },
    # WhisperSpeech
    'collabora/WhisperSpeech': {
        'name': 'WhisperSpeech',
        'function': '/whisper_speech_demo',
        'text_param_index': 0,
        'return_audio_index': 0,
        'series': 'WhisperSpeech',
    },
    # OpenVoice (MyShell.ai)
    'myshell-ai/OpenVoice': {
        'name':'OpenVoice',
        'function': '1',
        'text_param_index': 0,
        'return_audio_index': 1,
        'series': 'OpenVoice',
    },
    # OpenVoice v2 (MyShell.ai)
    'myshell-ai/OpenVoiceV2': {
        'name':'OpenVoice v2',
        'function': '1',
        'text_param_index': 0,
        'return_audio_index': 1,
        'series': 'OpenVoice',
    },
    # MetaVoice
    'mrfakename/MetaVoice-1B-v0.1': {
        'name':'MetaVoice-1B',
        'function': '/tts',
        'text_param_index': 0,
        'return_audio_index': 0,
        'series': 'MetaVoice-1B',
    },
    # xVASynth (CPU)
    'Pendrokar/xVASynth-TTS': {
        'name': 'xVASynth v3',
        'function': '/predict',
        'text_param_index': 0,
        'return_audio_index': 0,
        'series': 'xVASynth',
    },
    # CoquiTTS (CPU)
    'coqui/CoquiTTS': {
        'name': 'CoquiTTS',
        'function': '0',
        'text_param_index': 0,
        'return_audio_index': 0,
        'series': 'CoquiTTS',
    },
    # HierSpeech_TTS
    'LeeSangHoon/HierSpeech_TTS': {
        'name': 'HierSpeech++',
        'function': '/predict',
        'text_param_index': 0,
        'return_audio_index': 0,
        'series': 'HierSpeech++',
    },
    # MeloTTS (MyShell.ai)
    'mrfakename/MeloTTS': {
        'name': 'MeloTTS',
        'function': '/synthesize',
        'text_param_index': 0,
        'return_audio_index': 0,
        'series': 'MeloTTS',
    },

    # Parler
    'parler-tts/parler_tts': {
        'name': 'Parler Mini',
        'function': '/gen_tts',
        'text_param_index': 0,
        'return_audio_index': 0,
        'is_zero_gpu_space': True,
        'series': 'Parler',
    },
    # Parler Mini
    # 'parler-tts/parler_tts': {
    #     'name': 'Parler Large',
    #     'function': '/gen_tts',
    #     'text_param_index': 0,
    #     'return_audio_index': 0,
    #     'is_zero_gpu_space': True,
    #    'series': 'Parler',
    # },
    # Parler Mini which using Expresso dataset
    'parler-tts/parler-tts-expresso': {
        'name': 'Parler Mini Expresso',
        'function': '/gen_tts',
        'text_param_index': 0,
        'return_audio_index': 0,
        'is_zero_gpu_space': True,
        'series': 'Parler',
    },

    # Microsoft Edge TTS
    'innoai/Edge-TTS-Text-to-Speech': {
        'name': 'Microsoft‚Ñ¢ Edge TTS',
        'function': '/predict',
        'text_param_index': 0,
        'return_audio_index': 0,
        'is_closed_off': True,
        'series': 'Edge TTS',
    },

    # Fish Speech
    'fishaudio/fish-speech-1': {
        'name': 'Fish Speech',
        'function': '/inference_wrapper',
        'text_param_index': 0,
        'return_audio_index': 0,
        'series': 'Fish Speech',
    },

    # E2/F5 TTS
    'mrfakename/E2-F5-TTS': {
        'name': 'F5 TTS',
        'function': '/basic_tts',
        'text_param_index': 2,
        'return_audio_index': 0,
        'is_zero_gpu_space': True,
        'series': 'E2/F5 TTS',
    },

    # IMS-Toucan
    'Flux9665/MassivelyMultilingualTTS': {
        'name': 'IMS-Toucan',
		'function': "/predict",
        'text_param_index': 0,
        'return_audio_index': 0,
        'series': 'IMS-Toucan',
    },

    # IMS-Toucan English non-artificial
    'Flux9665/EnglishToucan': {
        'name': 'IMS-Toucan EN',
		'function': "/predict",
        'text_param_index': 0,
        'return_audio_index': 0,
        'is_zero_gpu_space': True,
        'series': 'IMS-Toucan',
    },

    # StyleTTS v2
    'Pendrokar/style-tts-2': {
        'name': 'StyleTTS v2',
        'function': '/synthesize',
        'text_param_index': 0,
        'return_audio_index': 0,
        # 'is_zero_gpu_space': True,
        'series': 'StyleTTS',
    },

    # StyleTTS v2 kokoro fine tune
    'hexgrad/kokoro': {
        'name': 'StyleTTS Kokoro',
        'function': '/generate',
        'text_param_index': 0,
        'return_audio_index': 0,
        'is_zero_gpu_space': True,
        'is_closed_off': True,
        'series': 'StyleTTS',
    },

    # MaskGCT (by Amphion)
    'amphion/maskgct': {
        'name': 'MaskGCT',
        'function': '/predict',
        'text_param_index': 1,
        'return_audio_index': 0,
        'is_zero_gpu_space': True,
        'series': 'MaskGCT',
    },
    'Svngoku/maskgct-audio-lab': {
        'name': 'MaskGCT',
        'function': '/predict',
        'text_param_index': 1,
        'return_audio_index': 0,
        'is_zero_gpu_space': True,
        'series': 'MaskGCT',
    },

    # TTS w issues
    # 'PolyAI/pheme': '/predict#0', #sleepy HF Space
    # 'amphion/Text-to-Speech': '/predict#0', #takes a whole minute to synthesize
    # 'suno/bark': '3#0', # Hallucinates
    # 'shivammehta25/Matcha-TTS': '5#0', #seems to require multiple requests for setup
    # 'styletts2/styletts2': '0#0', #API disabled
    # 'Manmay/tortoise-tts': '/predict#0', #Cannot skip text-from-file parameter
    # 'pytorch/Tacotron2': '0#0', #old gradio
    # 'fishaudio/fish-speech-1': '/inference_wrapper#0', heavy hallucinations
}

# for zero-shot TTS - voice sample used by XTTS (11 seconds)
DEFAULT_VOICE_SAMPLE_STR = 'https://cdn-uploads.huggingface.co/production/uploads/63d52e0c4e5642795617f668/V6-rMmI-P59DA4leWDIcK.wav'
DEFAULT_VOICE_SAMPLE = handle_file(DEFAULT_VOICE_SAMPLE_STR)
DEFAULT_VOICE_TRANSCRIPT = "The Hispaniola was rolling scuppers under in the ocean swell. The booms were tearing at the blocks, the rudder was banging to and fro, and the whole ship creaking, groaning, and jumping like a manufactory."

OVERRIDE_INPUTS = {
    'coqui/xtts': {
        1: 'en',
        2: DEFAULT_VOICE_SAMPLE_STR, # voice sample
        3: None, # mic voice sample
        4: False, #use_mic
        5: False, #cleanup_reference
        6: False, #auto_detect
    },
    'collabora/WhisperSpeech': {
        1: DEFAULT_VOICE_SAMPLE, # voice sample
        2: DEFAULT_VOICE_SAMPLE, # voice sample URL
        3: 14.0, #Tempo - Gradio Slider issue: takes min. rather than value
    },
    'myshell-ai/OpenVoice': {
        1: 'default', # style
        2: 'https://huggingface.co/spaces/myshell-ai/OpenVoiceV2/resolve/main/examples/speaker0.mp3', # voice sample
    },
    'myshell-ai/OpenVoiceV2': {
        1: 'en_us', # style
        2: 'https://huggingface.co/spaces/myshell-ai/OpenVoiceV2/resolve/main/examples/speaker0.mp3', # voice sample
    },
    'PolyAI/pheme': {
        1: 'YOU1000000044_S0000798', # voice
        2: 210,
        3: 0.7, #Tempo - Gradio Slider issue: takes min. rather than value
    },
    'Pendrokar/xVASynth-TTS': {
        1: 'x_ex04', #fine-tuned voice model name
        3: 1.0, #pacing/duration - Gradio Slider issue: takes min. rather than value
    },
    'suno/bark': {
        1: 'Speaker 3 (en)', # voice
    },
    'amphion/Text-to-Speech': {
        1: 'LikeManyWaters', # voice
    },
    'LeeSangHoon/HierSpeech_TTS': {
        1: handle_file('https://huggingface.co/spaces/LeeSangHoon/HierSpeech_TTS/resolve/main/example/female.wav'), # voice sample
        2: 0.333,
        3: 0.333,
        4: 1,
        5: 1,
        6: 0,
        7: 1111,
    },
    'Manmay/tortoise-tts': {
        1: None, # text-from-file
        2: 'angie', # voice
        3: 'disabled', # second voice for a dialogue
        4: 'No', # split by newline
    },
    'mrfakename/MeloTTS': {
        1: 'EN-Default',	# speaker; DEFAULT_VOICE_SAMPLE=EN-Default
        2: 1, # speed
        3: 'EN',	# language
    },
    'mrfakename/MetaVoice-1B-v0.1': {
		1: 5,	# float (numeric value between 0.0 and 10.0) in 'Speech Stability - improves text following for a challenging speaker' Slider component
		2: 5,	# float (numeric value between 1.0 and 5.0) in 'Speaker similarity - How closely to match speaker identity and speech style.' Slider component
		3: "Preset voices",	# Literal['Preset voices', 'Upload target voice']  in 'Choose voice' Radio component
		4: "Bria",	# Literal['Bria', 'Alex', 'Jacob']  in 'Preset voices' Dropdown component
		5: None,	# filepath  in 'Upload a clean sample to clone. Sample should contain 1 speaker, be between 30-90 seconds and not contain background noise.' Audio component
    },
    'parler-tts/parler_tts': {
        1: 'Laura; Laura\'s female voice; very clear audio', # description/prompt
    },
    'parler-tts/parler-tts-expresso': {
        1: 'Elisabeth; Elisabeth\'s female voice; very clear audio', # description/prompt
    },
    'innoai/Edge-TTS-Text-to-Speech': {
        1: 'en-US-EmmaMultilingualNeural - en-US (Female)', # voice
        2: 0, # pace rate
        3: 0, # pitch
    },

    'fishaudio/fish-speech-1': {
        1: False, # normalize
		2: handle_file('https://huggingface.co/spaces/fishaudio/fish-speech-1/resolve/main/examples/English.wav'), # reference_audio
		3: 'In the ancient land of Eldoria, where the skies were painted with shades of mystic hues and the forests whispered secrets of old, there existed a dragon named Zephyros. Unlike the fearsome tales of dragons that plagued human hearts with terror, Zephyros was a creature of wonder and wisdom, revered by all who knew of his existence.', # reference_text
		4: 0, # max_new_tokens
		5: 200, # chunk_length
		6: 0.7, # top_p
		7: 1.2, # repetition_penalty
		8: 0.7, # temperature
		9: 0, #seed
		10: "never", #use_memory_cache
    },

    'mrfakename/E2-F5-TTS': {
		0: DEFAULT_VOICE_SAMPLE, # voice sample
		1: DEFAULT_VOICE_TRANSCRIPT, # transcript of sample (< 15 seconds required)
		3: False, # cleanup silence
        4: 0.15, #crossfade
        5: 1, #speed
    },

    # IMS-Toucan
    'Flux9665/MassivelyMultilingualTTS': {
		1: "English (eng)", #language
		2: 0.6, #prosody_creativity
		3: 1, #duration_scaling_factor
		4: 41, #voice_seed
		5: 7.5, #emb1
		6: None, #reference_audio
    },

    # StyleTTS 2
    'Pendrokar/style-tts-2': {
		1: "f-us-2", #voice
        2: 'en-us', # lang
		3: 8, # lngsteps
    },

    # StyleTTS 2 kokoro
    'hexgrad/kokoro': {
		1: "af", #voice
		2: None, #ps
		3: 1, #speed
		4: 3000, #trim
		5: False, #use_gpu; fast enough with multithreaded with CPU
    },

    # maskGCT (by amphion)
    'amphion/maskgct': {
        0: DEFAULT_VOICE_SAMPLE, #prompt_wav
		2: -1, #target_len
		3: 25, #n_timesteps
    },
    'Svngoku/maskgct-audio-lab': {
        0: DEFAULT_VOICE_SAMPLE, #prompt_wav
		2: -1, #target_len
		3: 25, #n_timesteps
    },
}

hf_clients: Tuple[Client] = {}
# cache audio samples for quick voting
cached_samples: List[Sample] = []
voting_users = {
    # userid as the key and USER() as the value
}
# top five models in order to always have one of them picked and scrutinized
top_five = ['fishaudio/fish-speech-1'] # fish 1.5

def generate_matching_pairs(samples: List[Sample]) -> List[Tuple[Sample, Sample]]:
    transcript_groups: Dict[str, List[Sample]] = {}
    samples = random.sample(samples, k=len(samples))
    for sample in samples:
        if sample.transcript not in transcript_groups:
            transcript_groups[sample.transcript] = []
        transcript_groups[sample.transcript].append(sample)

    matching_pairs: List[Tuple[Sample, Sample]] = []
    for group in transcript_groups.values():
        matching_pairs.extend(list(itertools.combinations(group, 2)))

    return matching_pairs

cached_audio = []

# @spaces.GPU(duration=10)
def asr_cached_for_dataset():

    for caudio in cached_audio:
        pass
    return True

# List[Tuple[Sample, Sample]]
all_pairs = []

SPACE_ID = os.getenv('SPACE_ID')
MAX_SAMPLE_TXT_LENGTH = 300
MIN_SAMPLE_TXT_LENGTH = 10
DB_DATASET_ID = os.getenv('DATASET_ID')
DB_NAME = "database.db"

SPACE_ID = 'TTS-AGI/TTS-Arena'

# If /data available => means local storage is enabled => let's use it!
DB_PATH = f"/data/{DB_NAME}" if os.path.isdir("/data") else DB_NAME
print(f"Using {DB_PATH}")
# AUDIO_DATASET_ID = "ttseval/tts-arena-new"
CITATION_TEXT = """@misc{tts-arena,
	title        = {Text to Speech Arena},
	author       = {mrfakename and Srivastav, Vaibhav and Fourrier, Cl√©mentine and Pouget, Lucain and Lacombe, Yoach and main and Gandhi, Sanchit},
	year         = 2024,
	publisher    = {Hugging Face},
	howpublished = "\\url{https://huggingface.co/spaces/TTS-AGI/TTS-Arena}"
}"""

####################################
# Functions
####################################

def create_db_if_missing():
    conn = get_db()
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS model (
            name TEXT UNIQUE,
            upvote INTEGER,
            downvote INTEGER
        );
    ''')
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS vote (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT,
            model TEXT,
            vote INTEGER,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
    ''')
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS votelog (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT,
            chosen TEXT,
            rejected TEXT,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
    ''')
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS spokentext (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            votelog_id INTEGER UNIQUE,
            spokentext TEXT,
            lang TEXT,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
    ''')
    # foreign keys
    cursor.execute('''
        CREATE UNIQUE INDEX IF NOT EXISTS st_to_vl ON spokentext(votelog_id);
    ''')
def get_db():
    return sqlite3.connect(DB_PATH)



####################################
# Space initialization
####################################

# Download existing DB
if not os.path.isfile(DB_PATH):
    print("Downloading DB...")
    try:
        cache_path = hf_hub_download(repo_id=DB_DATASET_ID, repo_type='dataset', filename=DB_NAME)
        shutil.copyfile(cache_path, DB_PATH)
        print("Downloaded DB")
    except Exception as e:
        print("Error while downloading DB:", e)

# Create DB table (if doesn't exist)
create_db_if_missing()

hf_token = os.getenv('HF_TOKEN')
# Sync local DB with remote repo every 5 minute (only if a change is detected)
scheduler = CommitScheduler(
    repo_id=DB_DATASET_ID,
    repo_type="dataset",
    folder_path=Path(DB_PATH).parent,
    every=5,
    allow_patterns=DB_NAME,
)

# Load audio dataset
# audio_dataset = load_dataset(AUDIO_DATASET_ID)


# prioritize low vote models
sql = 'SELECT name FROM model WHERE (upvote + downvote) < 750 ORDER BY (upvote + downvote) ASC'
conn = get_db()
cursor = conn.cursor()
cursor.execute(sql)
data = cursor.fetchall()
for model in data:
    if (
        len(top_five) >= 5
    ):
        break

    if model[0] in AVAILABLE_MODELS.keys():
        top_five.append(model[0])
print(f"low vote top_five: {top_five}")

####################################
# Router API
####################################
# router = Client("TTS-AGI/tts-router", hf_token=hf_token)
router = {}
####################################
# Gradio app
####################################
MUST_BE_LOGGEDIN = "Please login with Hugging Face to participate in the TTS Arena."
DESCR = """
# TTS Spaces Arena: Benchmarking Gradio hosted TTS Models in the Wild

Vote to help the community find the best available text-to-speech model!
""".strip()
INSTR = """
## üó≥Ô∏è Vote

* Press ‚ö° to get cached sample pairs you've yet to vote on. (Fast üêá)
* Or press üé≤ to randomly use a sentence from the list. (Slow üê¢)
* Or input text (üá∫üá∏ English only) to synthesize audio. (Slowest üêå due to _Toxicity_ test)
* Listen to the two audio clips, one after the other.
* _Vote on which audio sounds more natural to you._
* Model names are revealed after the vote is cast.

‚ö† Note: It **may take up to 30 seconds** to ***synthesize*** audio.
""".strip()
request = ''
if SPACE_ID:
    request = f"""
### Request a model

Clone the repo of this space, add your model by adding the parameters required of the HF Space. Then make a pull request to {SPACE_ID}.
"""
ABOUT = f"""
## üìÑ About

The TTS Arena evaluates leading speech synthesis models. It is inspired by LMsys's [Chatbot Arena](https://chat.lmsys.org/).

### Motivation

The field of speech synthesis has long lacked an accurate method to measure the quality of different models. Objective metrics like WER (word error rate) are unreliable measures of model quality, and subjective measures such as MOS (mean opinion score) are typically small-scale experiments conducted with few listeners. As a result, these measurements are generally not useful for comparing two models of roughly similar quality. To address these drawbacks, we are inviting the community to rank models in an easy-to-use interface, and opening it up to the public in order to make both the opportunity to rank models, as well as the results, more easily accessible to everyone.

### The Arena

The leaderboard allows a user to enter text, which will be synthesized by two models. After listening to each sample, the user can vote on which model sounds more natural. Due to the risks of human bias and abuse, model names are revealed only after a vote is submitted.

### Credits

Thank you to the following individuals who helped make this* project possible:

* VB ([Twitter](https://twitter.com/reach_vb) / [Hugging Face](https://huggingface.co/reach-vb))
* Cl√©mentine Fourrier ([Twitter](https://twitter.com/clefourrier) / [Hugging Face](https://huggingface.co/clefourrier))
* Lucain Pouget ([Twitter](https://twitter.com/Wauplin) / [Hugging Face](https://huggingface.co/Wauplin))
* Yoach Lacombe ([Twitter](https://twitter.com/yoachlacombe) / [Hugging Face](https://huggingface.co/ylacombe))
* Main Horse ([Twitter](https://twitter.com/main_horse) / [Hugging Face](https://huggingface.co/main-horse))
* Sanchit Gandhi ([Twitter](https://twitter.com/sanchitgandhi99) / [Hugging Face](https://huggingface.co/sanchit-gandhi))
* Apolin√°rio Passos ([Twitter](https://twitter.com/multimodalart) / [Hugging Face](https://huggingface.co/multimodalart))
* Pedro Cuenca ([Twitter](https://twitter.com/pcuenq) / [Hugging Face](https://huggingface.co/pcuenq))

\* ***You are currently in a cloned/forked space of TTS-AGI/TTS-Arena***

{request}

### Privacy statement

We may store text you enter and generated audio. We store a unique ID for each session. You agree that we may collect, share, and/or publish any data you input for research and/or commercial purposes.

### License

Generated audio clips cannot be redistributed and may be used for personal, non-commercial use only.

Random sentences are sourced from a filtered subset of the [Harvard Sentences](https://www.cs.columbia.edu/~hgs/audio/harvard.html) and also from KingNish's generated LLM sentences.
""".strip()

LDESC = f"""
## üèÜ Leaderboard

Vote to help the community determine the best text-to-speech (TTS) models.

The leaderboard displays models in descending order of how natural they sound (based on votes cast by the community).

Important: In order to help keep results fair, the leaderboard hides results by default until the number of votes passes a threshold. Tick the `Reveal preliminary results` to show models without sufficient votes. Please note that preliminary results may be inaccurate. [This dataset is public](https://huggingface.co/datasets/{DB_DATASET_ID}) and only saves the hardcoded sentences while keeping the voters anonymous.
""".strip()

TTS_INFO = f"""
## üó£ Contenders

### Open Source TTS capabilities table

See [the below dataset itself](https://huggingface.co/datasets/Pendrokar/open_tts_tracker) for the legend and more in depth information of each model.
""".strip()

model_series = []
for model in HF_SPACES.values():
    model_series.append('%27'+ model['series'].replace('+', '%2B') +'%27')
TTS_DATASET_IFRAME_ORDER = '%2C+'.join(model_series)
TTS_DATASET_IFRAME = f"""
<iframe
    src="https://huggingface.co/datasets/Pendrokar/open_tts_tracker/embed/sql-console/default/train?sql_console=true&sql=--+The+SQL+console+is+powered+by+DuckDB+WASM+and+runs+entirely+in+the+browser.%0A--+Get+started+by+typing+a+query+or+selecting+a+view+from+the+options+below.%0ASELECT+*%2C+%22Name%22+IN+%28{TTS_DATASET_IFRAME_ORDER}%29+AS+%22In+arena%22+FROM+train+WHERE+%22Insta-clone+%F0%9F%91%A5%22+IS+NOT+NULL+ORDER+BY+%22In+arena%22+DESC+LIMIT+50%3B&views%5B%5D=train"
    frameborder="0"
    width="100%"
    height="650px"
></iframe>
""".strip()

# def reload_audio_dataset():
#     global audio_dataset
#     audio_dataset = load_dataset(AUDIO_DATASET_ID)
#     return 'Reload Audio Dataset'

def del_db(txt):
    if not txt.lower() == 'delete db':
        raise gr.Error('You did not enter "delete db"')

    # Delete local + remote
    os.remove(DB_PATH)
    delete_file(path_in_repo=DB_NAME, repo_id=DB_DATASET_ID, repo_type='dataset')

    # Recreate
    create_db_if_missing()
    return 'Delete DB'

theme = gr.themes.Base(
    font=[gr.themes.GoogleFont('Libre Franklin'), gr.themes.GoogleFont('Public Sans'), 'system-ui', 'sans-serif'],
)

model_names = {
    'styletts2': 'StyleTTS 2',
    'tacotron': 'Tacotron',
    'tacotronph': 'Tacotron Phoneme',
    'tacotrondca': 'Tacotron DCA',
    'speedyspeech': 'Speedy Speech',
    'overflow': 'Overflow TTS',
    'vits': 'VITS',
    'vitsneon': 'VITS Neon',
    'neuralhmm': 'Neural HMM',
    'glow': 'Glow TTS',
    'fastpitch': 'FastPitch',
    'jenny': 'Jenny',
    'tortoise': 'Tortoise TTS',
    'xtts2': 'Coqui XTTSv2',
    'xtts': 'Coqui XTTS',
    'openvoice': 'MyShell OpenVoice',
    'elevenlabs': 'ElevenLabs',
    'openai': 'OpenAI',
    'hierspeech': 'HierSpeech++',
    'pheme': 'PolyAI Pheme',
    'speecht5': 'SpeechT5',
    'metavoice': 'MetaVoice-1B',
}
model_licenses = {
    'styletts2': 'MIT',
    'tacotron': 'BSD-3',
    'tacotronph': 'BSD-3',
    'tacotrondca': 'BSD-3',
    'speedyspeech': 'BSD-3',
    'overflow': 'MIT',
    'vits': 'MIT',
    'openvoice': 'MIT',
    'vitsneon': 'BSD-3',
    'neuralhmm': 'MIT',
    'glow': 'MIT',
    'fastpitch': 'Apache 2.0',
    'jenny': 'Jenny License',
    'tortoise': 'Apache 2.0',
    'xtts2': 'CPML (NC)',
    'xtts': 'CPML (NC)',
    'elevenlabs': 'Proprietary',
    'eleven': 'Proprietary',
    'openai': 'Proprietary',
    'hierspeech': 'MIT',
    'pheme': 'CC-BY',
    'speecht5': 'MIT',
    'metavoice': 'Apache 2.0',
    'elevenlabs': 'Proprietary',
    'whisperspeech': 'MIT',
    'Pendrokar/xVASynth': 'GPT3',
}
model_links = {
    'styletts2': 'https://github.com/yl4579/StyleTTS2',
    'tacotron': 'https://github.com/NVIDIA/tacotron2',
    'speedyspeech': 'https://github.com/janvainer/speedyspeech',
    'overflow': 'https://github.com/shivammehta25/OverFlow',
    'vits': 'https://github.com/jaywalnut310/vits',
    'openvoice': 'https://github.com/myshell-ai/OpenVoice',
    'neuralhmm': 'https://github.com/ketranm/neuralHMM',
    'glow': 'https://github.com/jaywalnut310/glow-tts',
    'fastpitch': 'https://fastpitch.github.io/',
    'tortoise': 'https://github.com/neonbjb/tortoise-tts',
    'xtts2': 'https://huggingface.co/coqui/XTTS-v2',
    'xtts': 'https://huggingface.co/coqui/XTTS-v1',
    'elevenlabs': 'https://elevenlabs.io/',
    'openai': 'https://help.openai.com/en/articles/8555505-tts-api',
    'hierspeech': 'https://github.com/sh-lee-prml/HierSpeechpp',
    'pheme': 'https://github.com/PolyAI-LDN/pheme',
    'speecht5': 'https://github.com/microsoft/SpeechT5',
    'metavoice': 'https://github.com/metavoiceio/metavoice-src',
}
def model_license(name):
    print(name)
    for k, v in AVAILABLE_MODELS.items():
        if k == name:
            if v in model_licenses:
                return model_licenses[v]
    print('---')
    return 'Unknown'
def get_leaderboard(reveal_prelim = False):
    conn = get_db()
    cursor = conn.cursor()
    sql = 'SELECT name, upvote, downvote, name AS orig_name FROM model'
    # if not reveal_prelim: sql += ' WHERE EXISTS (SELECT 1 FROM model WHERE (upvote + downvote) > 750)'
    if not reveal_prelim: sql += ' WHERE (upvote + downvote) > 300'
    cursor.execute(sql)
    data = cursor.fetchall()
    df = pd.DataFrame(data, columns=['name', 'upvote', 'downvote', 'orig_name'])
    # df['license'] = df['name'].map(model_license)
    df['name'] = df['name'].replace(model_names)
    for i in range(len(df)):
        df.loc[i, "name"] = make_link_to_space(df['name'][i], True)
    df['votes'] = df['upvote'] + df['downvote']
    # df['score'] = round((df['upvote'] / df['votes']) * 100, 2) # Percentage score

    ## ELO SCORE
    df['score'] = 1200
    for i in range(len(df)):
        for j in range(len(df)):
            if i != j:
                expected_a = 1 / (1 + 10 ** ((df['score'][j] - df['score'][i]) / 400))
                expected_b = 1 / (1 + 10 ** ((df['score'][i] - df['score'][j]) / 400))
                actual_a = df['upvote'][i] / df['votes'][i]
                actual_b = df['upvote'][j] / df['votes'][j]
                df.at[i, 'score'] += round(32 * (actual_a - expected_a))
                df.at[j, 'score'] += round(32 * (actual_b - expected_b))
    df['score'] = round(df['score'])
    ## ELO SCORE
    df = df.sort_values(by='score', ascending=False)
    # medals
    def assign_medal(rank, assign):
        rank = str(rank + 1)
        if assign:
            if rank == '1':
                rank += 'ü•á'
            elif rank == '2':
                rank += 'ü•à'
            elif rank == '3':
                rank += 'ü•â'

        return '#'+ rank

    df['order'] = [assign_medal(i, not reveal_prelim and len(df) > 2) for i in range(len(df))]
    # fetch top_five
    for orig_name in df['orig_name']:
        if (
            reveal_prelim
            and len(top_five) < 5
            and orig_name in AVAILABLE_MODELS.keys()
        ):
            top_five.append(orig_name)

    df = df[['order', 'name', 'score', 'votes']]
    return df

def make_link_to_space(model_name, for_leaderboard=False):
    # create a anchor link if a HF space
    style = 'text-decoration: underline;text-decoration-style: dotted;'
    title = ''

    if model_name in AVAILABLE_MODELS:
        style += 'color: var(--link-text-color);'
        title = model_name
    else:
        style += 'font-style: italic;'
        title = 'Disabled for Arena (See AVAILABLE_MODELS within code for why)'

    model_basename = model_name
    if model_name in HF_SPACES:
        model_basename = HF_SPACES[model_name]['name']

    try:
        if(
            for_leaderboard
            and HF_SPACES[model_name]['is_closed_off']
        ):
            model_basename += ' üîê'
            title += '; üîê = online only or proprietary'
    except:
        pass

    if '/' in model_name:
        return 'ü§ó <a target="_blank" style="'+ style +'" title="'+ title +'" href="'+ 'https://huggingface.co/spaces/'+ model_name +'">'+ model_basename +'</a>'

    # otherwise just return the model name
    return '<span style="'+ style +'" title="'+ title +'" href="'+ 'https://huggingface.co/spaces/'+ model_name +'">'+ model_name +'</span>'

def markdown_link_to_space(model_name):
    # create a anchor link if a HF space using markdown syntax
    if '/' in model_name:
        return 'ü§ó [' + model_name + '](https://huggingface.co/spaces/' + model_name + ')'
    # otherwise just return the model name
    return model_name

def mkuuid(uid):
    if not uid:
        uid = uuid.uuid4()
    return uid
def upvote_model(model, uname):
    conn = get_db()
    cursor = conn.cursor()
    cursor.execute('UPDATE model SET upvote = upvote + 1 WHERE name = ?', (model,))
    if cursor.rowcount == 0:
        cursor.execute('INSERT OR REPLACE INTO model (name, upvote, downvote) VALUES (?, 1, 0)', (model,))
    cursor.execute('INSERT INTO vote (username, model, vote) VALUES (?, ?, ?)', (uname, model, 1,))
    with scheduler.lock:
        conn.commit()
    cursor.close()
def log_text(text, voteid):
    # log only hardcoded sentences
    if (text not in sents):
        return

    conn = get_db()
    cursor = conn.cursor()
    # TODO: multilang
    cursor.execute('INSERT INTO spokentext (spokentext, lang, votelog_id) VALUES (?,?,?)', (text,'en',voteid))
    with scheduler.lock:
        conn.commit()
    cursor.close()
def downvote_model(model, uname):
    conn = get_db()
    cursor = conn.cursor()
    cursor.execute('UPDATE model SET downvote = downvote + 1 WHERE name = ?', (model,))
    if cursor.rowcount == 0:
        cursor.execute('INSERT OR REPLACE INTO model (name, upvote, downvote) VALUES (?, 0, 1)', (model,))
    cursor.execute('INSERT INTO vote (username, model, vote) VALUES (?, ?, ?)', (uname, model, -1,))
    with scheduler.lock:
        conn.commit()
    cursor.close()

def a_is_better(model1, model2, userid, text):
    return is_better(model1, model2, userid, text, True)
def b_is_better(model1, model2, userid, text):
    return is_better(model1, model2, userid, text, False)

def is_better(model1, model2, userid, text, chose_a):
    if(
        (
            not model1 in AVAILABLE_MODELS.keys()
            and not model1 in AVAILABLE_MODELS.values()
        )
        or (
            not model2 in AVAILABLE_MODELS.keys()
            and not model2 in AVAILABLE_MODELS.values()
        )
    ):
        raise gr.Error('Sorry, please try voting again.')

    # userid is unique for each cast vote pair
    userid = mkuuid(userid)
    if model1 and model2:
        conn = get_db()
        cursor = conn.cursor()
        sql_query = 'INSERT INTO votelog (username, chosen, rejected) VALUES (?, ?, ?)'
        if chose_a:
            cursor.execute(sql_query, (str(userid), model1, model2))
        else:
            cursor.execute(sql_query, (str(userid), model2, model1))

        with scheduler.lock:
            conn.commit()
            # also retrieve primary key ID
            cursor.execute('SELECT last_insert_rowid()')
            votelogid = cursor.fetchone()[0]
            cursor.close()

        if chose_a:
            upvote_model(model1, str(userid))
            downvote_model(model2, str(userid))
        else:
            upvote_model(model2, str(userid))
            downvote_model(model1, str(userid))
        log_text(text, votelogid)

    return reload(model1, model2, userid, chose_a=chose_a, chose_b=(not chose_a))

def both_bad(model1, model2, userid):
    userid = mkuuid(userid)
    if model1 and model2:
        downvote_model(model1, str(userid))
        downvote_model(model2, str(userid))
    return reload(model1, model2, userid)
def both_good(model1, model2, userid):
    userid = mkuuid(userid)
    if model1 and model2:
        upvote_model(model1, str(userid))
        upvote_model(model2, str(userid))
    return reload(model1, model2, userid)
def reload(chosenmodel1=None, chosenmodel2=None, userid=None, chose_a=False, chose_b=False):
    # Select random splits
    chosenmodel1 = make_link_to_space(chosenmodel1)
    chosenmodel2 = make_link_to_space(chosenmodel2)
    out = [
        gr.update(interactive=False, visible=False),
        gr.update(interactive=False, visible=False)
    ]
    style = 'text-align: center; font-size: 1rem; margin-bottom: 0; padding: var(--input-padding)'
    if chose_a == True:
        out.append(gr.update(value=f'<p style="{style}">Your vote: {chosenmodel1}</p>', visible=True))
        out.append(gr.update(value=f'<p style="{style}">{chosenmodel2}</p>', visible=True))
    else:
        out.append(gr.update(value=f'<p style="{style}">{chosenmodel1}</p>', visible=True))
        out.append(gr.update(value=f'<p style="{style}">Your vote: {chosenmodel2}</p>', visible=True))
    out.append(gr.update(visible=True))
    return out

with gr.Blocks() as leaderboard:
    gr.Markdown(LDESC)
    # df = gr.Dataframe(interactive=False, value=get_leaderboard())
    df = gr.Dataframe(
        interactive=False,
        min_width=0,
        wrap=True,
        column_widths=[30, 200, 50, 50],
        datatype=["str", "html", "number", "number"]
    )
    with gr.Row():
        reveal_prelim = gr.Checkbox(label="Reveal preliminary results", info="Show all models, including models with very few human ratings.", scale=1)
        reloadbtn = gr.Button("Refresh", scale=3)
    reveal_prelim.input(get_leaderboard, inputs=[reveal_prelim], outputs=[df])
    leaderboard.load(get_leaderboard, inputs=[reveal_prelim], outputs=[df])
    reloadbtn.click(get_leaderboard, inputs=[reveal_prelim], outputs=[df])
    # gr.Markdown("DISCLAIMER: The licenses listed may not be accurate or up to date, you are responsible for checking the licenses before using the models. Also note that some models may have additional usage restrictions.")

def doloudnorm(path):
    data, rate = sf.read(path)
    meter = pyln.Meter(rate)
    loudness = meter.integrated_loudness(data)
    loudness_normalized_audio = pyln.normalize.loudness(data, loudness, -12.0)
    sf.write(path, loudness_normalized_audio, rate)

def doresample(path_to_wav):
    pass
##########################
# 2x speedup (hopefully) #
##########################

def synthandreturn(text, request: gr.Request):
    text = text.strip()
    if len(text) > MAX_SAMPLE_TXT_LENGTH:
        raise gr.Error(f'You exceeded the limit of {MAX_SAMPLE_TXT_LENGTH} characters')
    if len(text) < MIN_SAMPLE_TXT_LENGTH:
        raise gr.Error(f'Please input a text longer than {MIN_SAMPLE_TXT_LENGTH} characters')
    if (
        # test toxicity if not prepared text
        text not in sents
        and toxicity.predict(text)['toxicity'] > 0.8
    ):
        print(f'Detected toxic content! "{text}"')
        raise gr.Error('Your text failed the toxicity test')
    if not text:
        raise gr.Error(f'You did not enter any text')
    # Check language
    try:
        if (
            text not in sents
            and not detect(text) == "en"
        ):
            gr.Warning('Warning: The input text may not be in English')
    except:
        pass
    # Get two random models

    # forced model: your TTS model versus The World!!!
    # mdl1 = 'Pendrokar/xVASynth'

    # scrutinize the top five by always picking one of them
    if (len(top_five) >= 5):
        mdl1 = random.sample(top_five, 1)[0]
        vsModels = dict(AVAILABLE_MODELS)
        del vsModels[mdl1]
        # randomize position of the forced model
        mdl2 = random.sample(list(vsModels.keys()), 1)
        # forced random
        mdl1, mdl2 = random.sample(list([mdl1, mdl2[0]]), 2)
    else:
        # actual random
        mdl1, mdl2 = random.sample(list(AVAILABLE_MODELS.keys()), 2)

    print("[debug] Using", mdl1, mdl2)
    def predict_and_update_result(text, model, result_storage, request:gr.Request):

        hf_headers = {}
        try:
            if HF_SPACES[model]['is_zero_gpu_space']:
                hf_headers = {"X-IP-Token": request.headers['x-ip-token']}
        except:
            pass

        # re-attempt if necessary
        attempt_count = 0
        max_attempts = 1 # 3 =May cause 429 Too Many Request
        while attempt_count < max_attempts:
            try:
                if model in AVAILABLE_MODELS:
                    if '/' in model:
                        # Use public HF Space
                        # if (model not in hf_clients):
                        #     hf_clients[model] = Client(model, hf_token=hf_token, headers=hf_headers)
                        mdl_space = Client(model, hf_token=hf_token, headers=hf_headers)

                        # print(f"{model}: Fetching endpoints of HF Space")
                        # assume the index is one of the first 9 return params
                        return_audio_index = int(HF_SPACES[model]['return_audio_index'])
                        endpoints = mdl_space.view_api(all_endpoints=True, print_info=False, return_format='dict')
    
                        api_name = None
                        fn_index = None
                        end_parameters = None
                        # has named endpoint
                        if '/' == HF_SPACES[model]['function'][0]:
                            # audio sync function name
                            api_name = HF_SPACES[model]['function']
    
                            end_parameters = _get_param_examples(
                                endpoints['named_endpoints'][api_name]['parameters']
                            )
                        # has unnamed endpoint
                        else:
                            # endpoint index is the first character
                            fn_index = int(HF_SPACES[model]['function'])
    
                            end_parameters = _get_param_examples(
                                endpoints['unnamed_endpoints'][str(fn_index)]['parameters']
                            )

                        # override some or all default parameters
                        space_inputs = _override_params(end_parameters, model)

                        # force text
                        space_inputs[HF_SPACES[model]['text_param_index']] = text

                        print(f"{model}: Sending request to HF Space")
                        results = mdl_space.predict(*space_inputs, api_name=api_name, fn_index=fn_index)

                        # return path to audio
                        result = results
                        if (not isinstance(results, str)):
                            # return_audio_index may be a filepath string
                            result = results[return_audio_index]
                        if (isinstance(result, dict)):
                            # return_audio_index is a dictionary
                            result = results[return_audio_index]['value']
                    else:
                        # Use the private HF Space
                        result = router.predict(text, AVAILABLE_MODELS[model].lower(), api_name="/synthesize")
                else:
                    result = router.predict(text, model.lower(), api_name="/synthesize")
                break
            except Exception as e:
                attempt_count += 1
                raise gr.Error(f"{model}:"+ repr(e))
                # print(f"{model}: Unable to call API (attempt: {attempt_count})")
                # sleep for three seconds to avoid spamming the server with requests
                # time.sleep(3)

                # Fetch and store client again
                # hf_clients[model] = Client(model, hf_token=hf_token, headers=hf_headers)

        if attempt_count >= max_attempts:
            raise gr.Error(f"{model}: Failed to call model")
        else:
            print('Done with', model)

        try:
            with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as f:
                audio = AudioSegment.from_file(result)
                current_sr = audio.frame_rate
                if current_sr > 24000:
                    print(f"{model}: Resampling")
                    audio = audio.set_frame_rate(24000)
                try:
                    print(f"{model}: Trying to normalize audio")
                    audio = match_target_amplitude(audio, -20)
                except:
                    print(f"{model}: [WARN] Unable to normalize audio")
                audio.export(f.name, format="wav")
                os.unlink(result)
                result = f.name
                gr.Info('Audio from a TTS model received')
        except:
            print(f"{model}: [WARN] Unable to resample audio")
            pass
        if model in AVAILABLE_MODELS.keys(): model = AVAILABLE_MODELS[model]
        result_storage[model] = result

    def _get_param_examples(parameters):
        example_inputs = []
        for param_info in parameters:
            if (
                param_info['component'] == 'Radio'
                or param_info['component'] == 'Dropdown'
                or param_info['component'] == 'Audio'
                or param_info['python_type']['type'] == 'str'
            ):
                example_inputs.append(str(param_info['example_input']))
                continue
            if param_info['python_type']['type'] == 'int':
                example_inputs.append(int(param_info['example_input']))
                continue
            if param_info['python_type']['type'] == 'float':
                example_inputs.append(float(param_info['example_input']))
                continue
            if param_info['python_type']['type'] == 'bool':
                example_inputs.append(bool(param_info['example_input']))
                continue

        return example_inputs

    def _override_params(inputs, modelname):
        try:
            for key,value in OVERRIDE_INPUTS[modelname].items():
                inputs[key] = value
            print(f"{modelname}: Default inputs overridden by Arena")
        except:
            pass

        return inputs
    
    def _cache_sample(text, model):
        # skip caching if not hardcoded sentence
        if (text not in sents):
            return False

        already_cached = False
        # check if already cached
        for cached_sample in cached_samples:
            # TODO:replace cached with newer version
            if (cached_sample.transcript == text and cached_sample.modelName == model):
                already_cached = True
                return True

        if (already_cached):
            return False

        try:
            cached_samples.append(Sample(results[model], text, model))
        except:
            print('Error when trying to cache sample')
            return False

    mdl1k = mdl1
    mdl2k = mdl2
    print(mdl1k, mdl2k)
    if mdl1 in AVAILABLE_MODELS.keys(): mdl1k=AVAILABLE_MODELS[mdl1]
    if mdl2 in AVAILABLE_MODELS.keys(): mdl2k=AVAILABLE_MODELS[mdl2]
    results = {}
    print(f"Sending models {mdl1k} and {mdl2k} to API")

    # do not use multithreading when both spaces are ZeroGPU type
    if (
        # exists
        'is_zero_gpu_space' in HF_SPACES[mdl1]
        # is True
        and HF_SPACES[mdl1]['is_zero_gpu_space']
        and 'is_zero_gpu_space' in HF_SPACES[mdl2]
        and HF_SPACES[mdl2]['is_zero_gpu_space']
    ):
        # run Zero-GPU spaces one at a time
        predict_and_update_result(text, mdl1k, results, request)
        _cache_sample(text, mdl1k)

        predict_and_update_result(text, mdl2k, results, request)
        _cache_sample(text, mdl2k)
    else:
        # use multithreading
        thread1 = threading.Thread(target=predict_and_update_result, args=(text, mdl1k, results, request))
        thread2 = threading.Thread(target=predict_and_update_result, args=(text, mdl2k, results, request))

        thread1.start()
        # wait 3 seconds to calm hf.space domain
        time.sleep(3)
        thread2.start()
        # timeout in 2 minutes
        thread1.join(120)
        thread2.join(120)

        # cache the result
        for model in [mdl1k, mdl2k]:
            _cache_sample(text, model)
    
    #debug
    # print(results)
    # print(list(results.keys())[0])
    # y, sr = librosa.load(results[list(results.keys())[0]], sr=None)
    # print(sr)
    # print(list(results.keys())[1])
    # y, sr = librosa.load(results[list(results.keys())[1]], sr=None)
    # print(sr)
    #debug
    #     outputs = [text, btn, r2, model1, model2, aud1, aud2, abetter, bbetter, prevmodel1, prevmodel2, nxtroundbtn]

    # all_pairs = generate_matching_pairs(cached_samples)

    print(f"Retrieving models {mdl1k} and {mdl2k} from API")
    return (
        text,
        "Synthesize",
        gr.update(visible=True), # r2
        mdl1, # model1
        mdl2, # model2
        gr.update(visible=True, value=results[mdl1k], interactive=False, autoplay=True), # aud1
        gr.update(visible=True, value=results[mdl2k], interactive=False, autoplay=False), # aud2
        gr.update(visible=True, interactive=False), #abetter
        gr.update(visible=True, interactive=False), #bbetter
        gr.update(visible=False), #prevmodel1
        gr.update(visible=False), #prevmodel2
        gr.update(visible=False), #nxt round btn
        # reset gr.State aplayed & bplayed
        False, #aplayed
        False, #bplayed
    )

def unlock_vote(btn_index, aplayed, bplayed):
    # sample played
    if btn_index == 0:
        aplayed = True
    if btn_index == 1:
        bplayed = True

    # both audio samples played
    if bool(aplayed) and bool(bplayed):
        # print('Both audio samples played, voting unlocked')
        return [gr.update(interactive=True), gr.update(interactive=True), True, True]

    return [gr.update(), gr.update(), aplayed, bplayed]

def play_other(bplayed):
    return bplayed

def get_userid(session_hash: str, request):
    # JS cookie
    if (session_hash != ''):
        # print('auth by session cookie')
        return sha1(bytes(session_hash.encode('ascii')), usedforsecurity=False).hexdigest()

    if request.username:
        # print('auth by username')
        # by HuggingFace username - requires `auth` to be enabled therefore denying access to anonymous users
        return sha1(bytes(request.username.encode('ascii')), usedforsecurity=False).hexdigest()
    else:
        # print('auth by ip')
        # by IP address - unreliable when gradio within HTML iframe
        # return sha1(bytes(request.client.host.encode('ascii')), usedforsecurity=False).hexdigest()
        # by browser session cookie - Gradio on HF is run in an HTML iframe, access to parent session required to reach session token
        # return sha1(bytes(request.headers.encode('ascii'))).hexdigest()
        # by browser session hash - Not a cookie, session hash changes on page reload
        return sha1(bytes(request.session_hash.encode('ascii')), usedforsecurity=False).hexdigest()

# Give user a cached audio sample pair they have yet to vote on
def give_cached_sample(session_hash: str, request: gr.Request):
    # add new userid to voting_users from Browser session hash
    # stored only in RAM
    userid = get_userid(session_hash, request)

    if userid not in voting_users:
        voting_users[userid] = User(userid)

    def get_next_pair(user: User):
        # FIXME: all_pairs var out of scope
        # all_pairs = generate_matching_pairs(cached_samples)

        # for pair in all_pairs:
        for pair in generate_matching_pairs(cached_samples):
            hash1 = md5(bytes((pair[0].modelName + pair[0].transcript).encode('ascii'))).hexdigest()
            hash2 = md5(bytes((pair[1].modelName + pair[1].transcript).encode('ascii'))).hexdigest()
            pair_key = (hash1, hash2)
            if (
                pair_key not in user.voted_pairs
                # or in reversed order
                and (pair_key[1], pair_key[0]) not in user.voted_pairs
            ):
                return pair
        return None

    pair = get_next_pair(voting_users[userid])
    if pair is None:
        return [
            *clear_stuff(),
            # disable get cached sample button
            gr.update(interactive=False)
        ]

    return (
        gr.update(visible=True, value=pair[0].transcript, elem_classes=['blurred-text']),
        "Synthesize",
        gr.update(visible=True), # r2
        pair[0].modelName, # model1
        pair[1].modelName, # model2
        gr.update(visible=True, value=pair[0].filename, interactive=False, autoplay=True), # aud1
        gr.update(visible=True, value=pair[1].filename, interactive=False, autoplay=False), # aud2
        gr.update(visible=True, interactive=False), #abetter
        gr.update(visible=True, interactive=False), #bbetter
        gr.update(visible=False), #prevmodel1
        gr.update(visible=False), #prevmodel2
        gr.update(visible=False), #nxt round btn
        # reset aplayed, bplayed audio playback events
        False, #aplayed
        False, #bplayed
        # fetch cached btn
        gr.update(interactive=True)
    )

# note the vote on cached sample pair
def voted_on_cached(modelName1: str, modelName2: str, transcript: str, session_hash: str, request: gr.Request):
    userid = get_userid(session_hash, request)
    # print(f'userid voted on cached: {userid}')

    if userid not in voting_users:
        voting_users[userid] = User(userid)

    hash1 = md5(bytes((modelName1 + transcript).encode('ascii'))).hexdigest()
    hash2 = md5(bytes((modelName2 + transcript).encode('ascii'))).hexdigest()

    voting_users[userid].voted_pairs.add((hash1, hash2))
    return []

def randomsent():
    return '‚ö°', random.choice(sents), 'üé≤'
def clear_stuff():
    return [
        gr.update(visible=True, value="", elem_classes=[]),
        "Synthesize",
        gr.update(visible=False), # r2
        '', # model1
        '', # model2
        gr.update(visible=False, interactive=False, autoplay=False), # aud1
        gr.update(visible=False, interactive=False, autoplay=False), # aud2
        gr.update(visible=False, interactive=False), #abetter
        gr.update(visible=False, interactive=False), #bbetter
        gr.update(visible=False), #prevmodel1
        gr.update(visible=False), #prevmodel2
        gr.update(visible=False), #nxt round btn
        False, #aplayed
        False, #bplayed
    ]

def disable():
    return [gr.update(interactive=False), gr.update(interactive=False), gr.update(interactive=False), gr.update(interactive=False)]
def enable():
    return [gr.update(interactive=True), gr.update(interactive=True), gr.update(interactive=True), gr.update(interactive=True)]
def unblur_text():
    return gr.update(elem_classes=[])

# JavaScript within HTML head
head_js = ""
unblur_js = 'document.getElementById("arena-text-input").classList.remove("blurred-text")'
shortcut_js = """
<script>
function shortcuts(e) {
    var event = document.all ? window.event : e;
    switch (e.target.tagName.toLowerCase()) {
        case "input":
        case "textarea":
            break;
        default:
            switch (e.key.toLowerCase()) {
                case "a":
                    document.getElementById("arena-a-better").click();
                    break;
                case "b":
                    document.getElementById("arena-b-better").click();
                    break;
                case "n":
                    document.getElementById("arena-next-round").click();
                    break;
            }
    }
}
document.addEventListener('keypress', shortcuts, false);

"""
head_js += shortcut_js
head_js += open("cookie.js").read()
head_js += '</script>'

with gr.Blocks() as vote:
    session_hash = gr.Textbox(visible=False, value='')

    # sample played, using Checkbox so that JS can fetch the value
    aplayed = gr.Checkbox(visible=False, value=False)
    bplayed = gr.Checkbox(visible=False, value=False)
    # voter ID
    useridstate = gr.State()
    gr.Markdown(INSTR)
    with gr.Group():
        with gr.Row():
            cachedt = gr.Button('‚ö°', scale=0, min_width=0, variant='tool', interactive=True)
            text = gr.Textbox(
                container=False,
                show_label=False,
                placeholder="Enter text to synthesize",
                lines=1,
                max_lines=1,
                scale=9999999,
                min_width=0,
                elem_id="arena-text-input",
            )
            randomt = gr.Button('üé≤', scale=0, min_width=0, variant='tool')
        randomt\
            .click(randomsent, outputs=[cachedt, text, randomt])\
            .then(None, js="() => "+ unblur_js)
        btn = gr.Button("Synthesize", variant='primary')
    model1 = gr.Textbox(interactive=False, lines=1, max_lines=1, visible=False)
    model2 = gr.Textbox(interactive=False, lines=1, max_lines=1, visible=False)
    with gr.Row(visible=False) as r2:
        with gr.Column():
            with gr.Group():
                aud1 = gr.Audio(
                    interactive=False,
                    show_label=False,
                    show_download_button=False,
                    show_share_button=False,
                    waveform_options={'waveform_progress_color': '#EF4444'},
                    # var(--color-red-500)'}); gradio only accepts HEX and CSS color
                )
                abetter = gr.Button(
                    "A is better [a]",
                    elem_id='arena-a-better',
                    variant='primary',
                    interactive=False,
                )
                prevmodel1 = gr.HTML(show_label=False, value="Vote to reveal model A", visible=False)
        with gr.Column():
            with gr.Group():
                aud2 = gr.Audio(
                    interactive=False,
                    show_label=False,
                    show_download_button=False,
                    show_share_button=False,
                    waveform_options={'waveform_progress_color': '#3C82F6'},
                    # var(--secondary-500)'}); gradio only accepts HEX and CSS color
                )
                bbetter = gr.Button(
                    "B is better [b]",
                    elem_id='arena-b-better',
                    variant='primary',
                    interactive=False
                )
                prevmodel2 = gr.HTML(show_label=False, value="Vote to reveal model B", visible=False)
    nxtroundbtn = gr.Button(
        '‚ö° Next round [n]',
        elem_id='arena-next-round',
        visible=False
    )
    outputs = [
        text,
        btn,
        r2,
        model1,
        model2,
        aud1,
        aud2,
        abetter,
        bbetter,
        prevmodel1,
        prevmodel2,
        nxtroundbtn,
        aplayed,
        bplayed,
    ]
    """
    text,
        "Synthesize",
        gr.update(visible=True), # r2
        mdl1, # model1
        mdl2, # model2
        gr.update(visible=True, value=results[mdl1]), # aud1
        gr.update(visible=True, value=results[mdl2]), # aud2
        gr.update(visible=True, interactive=False), #abetter
        gr.update(visible=True, interactive=False), #bbetter
        gr.update(visible=False), #prevmodel1
        gr.update(visible=False), #prevmodel2
        gr.update(visible=False), #nxt round btn"""
    btn\
        .click(disable, outputs=[btn, abetter, bbetter, cachedt])\
        .then(synthandreturn, inputs=[text], outputs=outputs)\
        .then(enable, outputs=[btn, gr.State(), gr.State(), cachedt])\
        .then(None, js="() => "+ unblur_js)
    nxtroundbtn\
        .click(clear_stuff, outputs=outputs)\
        .then(disable, outputs=[btn, abetter, bbetter, cachedt])\
        .then(give_cached_sample, inputs=[session_hash], outputs=[*outputs, cachedt])\
        .then(enable, outputs=[btn, gr.State(), gr.State(), gr.State()])

    # fetch a comparison pair from cache
    cachedt\
        .click(disable, outputs=[btn, abetter, bbetter, cachedt])\
        .then(give_cached_sample, inputs=[session_hash], outputs=[*outputs, cachedt])\
        .then(enable, outputs=[btn, gr.State(), gr.State(), gr.State()])
    # TODO: await download of sample before allowing playback

    # Allow interaction with the vote buttons only when both audio samples have finished playing
    aud1\
        .stop(
            unlock_vote,
            outputs=[abetter, bbetter, aplayed, bplayed],
            inputs=[gr.State(value=0), aplayed, bplayed],
        )\
        .then(
            None,
            inputs=[bplayed],
            js="(b) => b ? 0 : document.querySelector('.row .gap+.gap button.play-pause-button[aria-label=Play]').click()",
        )
    # autoplay if unplayed
    aud2\
        .stop(
            unlock_vote,
            outputs=[abetter, bbetter, aplayed, bplayed],
            inputs=[gr.State(value=1), aplayed, bplayed],
        )\
        .then(None, js="() => "+ unblur_js)

    nxt_outputs = [abetter, bbetter, prevmodel1, prevmodel2, nxtroundbtn]
    abetter\
        .click(a_is_better, outputs=nxt_outputs, inputs=[model1, model2, useridstate, text])\
        .then(voted_on_cached, inputs=[model1, model2, text, session_hash], outputs=[])
    bbetter\
        .click(b_is_better, outputs=nxt_outputs, inputs=[model1, model2, useridstate, text])\
        .then(voted_on_cached, inputs=[model1, model2, text, session_hash], outputs=[])
    # skipbtn.click(b_is_better, outputs=outputs, inputs=[model1, model2, useridstate])

    # bothbad.click(both_bad, outputs=outputs, inputs=[model1, model2, useridstate])
    # bothgood.click(both_good, outputs=outputs, inputs=[model1, model2, useridstate])

    # get session cookie
    vote\
        .load(
            None,
            None,
            session_hash,
            js="() => { return getArenaCookie('session') }",
        )
    # give a cached sample pair to voter; .then() did not work here
    vote\
        .load(give_cached_sample, inputs=[session_hash], outputs=[*outputs, cachedt])

with gr.Blocks() as about:
    gr.Markdown(ABOUT)
with gr.Blocks() as tts_info:
    gr.Markdown(TTS_INFO)
    gr.HTML(TTS_DATASET_IFRAME)
# with gr.Blocks() as admin:
#     rdb = gr.Button("Reload Audio Dataset")
#     # rdb.click(reload_audio_dataset, outputs=rdb)
#     with gr.Group():
#         dbtext = gr.Textbox(label="Type \"delete db\" to confirm", placeholder="delete db")
#         ddb = gr.Button("Delete DB")
#     ddb.click(del_db, inputs=dbtext, outputs=ddb)
# Blur cached sample text so the voting user picks up mispronouncements
with gr.Blocks(theme=theme, css="footer {visibility: hidden}textbox{resize:none} .blurred-text {filter: blur(0.15em);}", head=head_js, title="TTS Arena") as demo:
    gr.Markdown(DESCR)
    # gr.TabbedInterface([vote, leaderboard, about, admin], ['Vote', 'Leaderboard', 'About', 'Admin (ONLY IN BETA)'])
    gr.TabbedInterface([vote, leaderboard, about, tts_info], ['üó≥Ô∏è Vote', 'üèÜ Leaderboard', 'üìÑ About', 'üó£ Contenders'])
    if CITATION_TEXT:
        with gr.Row():
            with gr.Accordion("Citation", open=False):
                gr.Markdown(f"If you use this data in your publication, please cite us!\n\nCopy the BibTeX citation to cite this source:\n\n```bibtext\n{CITATION_TEXT}\n```\n\nPlease remember that all generated audio clips should be assumed unsuitable for redistribution or commercial use.")


demo\
    .queue(api_open=False, default_concurrency_limit=4)\
    .launch(show_api=False, show_error=True)
